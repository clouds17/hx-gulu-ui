## vue3的样式穿透

vue3如果在父组件里直接设置子组件的属性，那么子组件会自动继承传过来的属性

如果你**不想要**一个组件自动地继承 attribute，你可以在组件选项中设置 `inheritAttrs: false`。

从 3.3 开始你也可以直接在 `<script setup>` 中使用 [`defineOptions`](https://cn.vuejs.org/api/sfc-script-setup.html#defineoptions)：

```vue
<script setup>
defineOptions({
  inheritAttrs: false
})
// ...setup 逻辑
</script>
```



如果想要穿透过来的attribute不是直接引用在最外层的元素上，比如：

```vue
<div>
	<button>我要继承</button>
</div>
```

如上所示，想要穿透过来的attribute放在button上，而不是放在div上，就可以通过设定`inheritAttrs: false` 和使用 `v-bind="$attrs"` 来实现：

```vue
<template>
<div>
  <button v-bind="$attrs">我要继承</button>
</div>
</template>
<script setup>
	defineOptions({
      inheritAttrs: false
    })
</script>
```





## scss中的遍历

```
$level-key: primary,success,info,warning,danger;
$level-value: #409EFF,#67C23A,#909399,#E6A23C,#F56C6C;
// for循环 $i 代表变量， 从1开始 到 $level-key 的length结束
@for $i from 1 through length($level-key) {
        $item: nth($level-key, $i);
        $value: nth($level-value, $i);
        &.hx-button-level__#{$item} {
            color: white;
            border-color: $value;
            background: $value;
        }
    }
}
```



## Teleport组件 

`<Teleport>` 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。

比如我向把某一部分的内容放到body下面，而不是在组件内部，#app里面

```
<Teleport to="body">
	<div>我要去给body当儿子</div>
</Teleport>
```





## 如和在运行时确保子组件的类型

用 useSlots

比如 我只想要 Tabs组件 里面只能用 Tab组件, 用法如下：

```
<Tabs>
	<Tab>我是子组件</Tab>
</Tabs>
```

实现

```
<template>
	<div>
		<component v-for="c in defaults" :is="c">
		<slot />
	</div>
</template>
// 为什么不直接用slot呢，因为slot会直接把所有内容渲染出来，虽然 js 还是会报错，但这样不好
// 用 component 会调用 defaults 把子组件一个一个渲染出来，这样比较符合
<script setup>
import { ref, useSlots } from 'vue';
import Tab from '@/lib/Tab.vue';

const slots = useSlots()
// 默认插槽 都在 default里，它是一个函数，执行后就能看到里面有多少个标签
console.log('slots', slots.default())
用返回的某一个元素里面的Type属性去和 Tab组件对比，如果是 那就是 TRUE
console.log('slots', slots.default()[0].type === Tab)

const defaults = slots.default()
defaults.forEach(item => {
	if (item.type !== Tab) {
		throw new Error('组件Tabs 里面的子标签只能是组件 Tab')
	}
})
</script>
```



## 获取元素的宽高位置

```
<template>
	<div ref="container"></div>
</template>
<script setup>
	import { ref } from 'vue';
	const container = ref(null)
	const { left, width, height } = container.value.getBoundingClientRect()
</script>
```



## watchEffect

某些场景下，想要刚开始的时候执行，有变化的时候也执行

```
import { onMounted, onUpdated, watchEffect } from 'vue';
onMounted(toggle)
onUpdated(toggle)
function toggle() {
    console.log('执行了')
}

// ===================
// 等同于上面

watchEffect(toggle)

```

